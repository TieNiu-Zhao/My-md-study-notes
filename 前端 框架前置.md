# 框架前置

## 事件类型的补充

- [loadend 事件](#loadend) 用于 XHR 对象，监听事件响应
- [request 事件](#http 模块)，这个事件是用 node.js 的服务器对象监听的，用于监听请求以提供 web 服务

## AJAX

使用 JSON，XML，HTML 和 text 文本发送和接收数据，具有异步特性，也就是说可以在不刷新页面的情况下与服务器进行通信，交换数据，或更新页面。

### axios 库 - 查询/提交/错误

1. 引入：https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js

2. axios 的使用：

   **axios** ({ url 后接服务器地址 })**.then** ( 回调函数 - 对服务器返回数据做后续处理 )

   **不含查询参数：**

   ```html
   <p class="my-p"></p>
   <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   <script>
       // 获取 axios 函数
       axios({
           url: 'http://hmajax.itheima.net/api/province'     // 服务器地址
       }).then(result => {
           // 对象，包含 data: {message: "成功", list: [// 数据列表]}
           console.log(result)
           // 数据
           console.log(result.data.list)
           // 使用 join 方法拼接数组
           console.log(result.data.list.join('<br>'))
           // 将数据显示到网页内
           document.querySelector('.my-p').innerHTML = result.data.list.join('<br>')
       })
   </script>
   ```

3. URL

   URL 指统一资源定位符，即网址。用于访问网上的资源。

   结构为：**协议://域名/资源路径**

   http 与 https 对应**协议**，指定浏览器与服务器之间传输数据的格式

   com、net 前的部分对应**域名**，标记服务器在互联网中的方位

   com、net 后的部分对应**资源路径**，标记资源在服务器下的具体位置

4. URL **传参数查询 params: {}**

   即给服务器额外信息，让服务器返回浏览器想要的数据。

   比如服务器上是不同省城市列表，提出需求想要黑龙江省下的城市，那么要把“黑龙江省”作为参数传到服务器

   参数会在 URL 网址后的 ? 后拼接

   ```html
   <p class="my-p"></p>
   <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   <script>
       // 获取 axios 函数
       axios({
           url: 'http://hmajax.itheima.net/api/city',     // 服务器地址
           params:{
               // 前面的参数值要看后端怎么给，后面是查询值
               pname: '黑龙江省'
           }
           // 以上内容相当于 http://hmajax.itheima.net/api/city?pname=黑龙江省
       }).then(result => {
           console.log(result.data.list)
           // 将数据显示到网页内
           document.querySelector('.my-p').innerHTML = result.data.list.join('<br>')
       })
   </script>
   ```

   【[案例 - 地区查询](#地区查询)】

5. **数据提交** **method: 'post' + data{}**

   把数据传到服务器上保存。

   例如需求为：通过 axios，提交用户名和密码，完成注册功能，URL由后端告知，参数名为 username（中英文数字，最少 8 位），password 密码（最少 6 位）

   **请求方法为 POST**

   method 的常用方法除了 POST 还有 GET，GET是获取数据，通常可省略，即省略 method: 'get'

   ```html
   <button class="btn">注册就送屠龙宝刀</button>
   <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   <script>
       document.querySelector('.btn').addEventListener('click', () => {
           axios({
               url: 'http://hmajax.itheima.net/api/register',		// 服务器地址
               method: 'post',                                		// 绑定请求方法
               data: {												// 要提交的数据
                   username: 'crazytieniu',
                   password: '1767577'
               }
           }).then(result => {
               console.log(result)
           })
       })
   </script>
   ```

6. 错误处理 **catch** ( error => { })

   上面的注册按钮点击两次会报错，因为已经注册过了。

   axios 产生的错误信息可以取出，用来给用户更直观的展现。

   在 axios().then() 后接 .**catch**( ) 表示 axios 成功执行 then 的回调函数，失败执行 catch 的回调函数

   ```javascript
   axios({
       // axios 内容
   }).then(result => {
       // 处理部分
   }).catch(error => {
       console.log(error)                                // 错误对象，包含response:{data:{message}}
       console.log(error.response.data.message)          // 账号被占用
       alert(error.response.data.message)
   })
   ```

---

### 报文与接口文档

1. 请求报文与响应报文

   请求报文可以再浏览器 F12 - 网络 - Fetch / XHR -（点击）名称 - 标头下点击源码查看。

   **请求报文可以帮助排查错误**，可以以使用上面的方法检查传给服务器的报文有无问题，以定位代码错误。

   响应报文中包含 HTTP 响应状态码：用来表明请求**是否成功**完成

   | 状态码 |      说明      |
   | :----: | :------------: |
   |  1xx   |      信息      |
   |  2xx   |    **成功**    |
   |  3xx   |   重定向消息   |
   |  4xx   | **客户端错误** |
   |  5xx   |   服务端错误   |

2. 接口文档

   即后端提供的描述接口的文章。类似于图示：

   ![](./\图片\接口文档.png)

   【[案例 - 用户登录](#用户登录)】

---


### form - seralize 插件

- 此插件可以快速获得表单的值。而不是用 value 去取。**无论有多少表单元素，都可以快速取得**。

   表单 form 中的元素要设置 **name 属性，将作为获取对象的属性名**。因此 name 属性值强烈建议和接口文档的属性名一致。

   配置对象：{hash: true, empty: true}

   hash 为设置获取数据结构，取值为 true 获取的是对象形式，取值为 false 获取得是查询字符串（URL 的形式）

   empty 为设置是否获取空值。

   ```html
   <body>
       <form action="javascript:;" class="example-form">
           <input type="text" name="username">
           <br>
           <input type="text" name="password">
           <br>
           <input type="button" class="btn" value="提交">
       </form>
       <!-- 引入 form-serialize 插件 -->
       <script src="./js/form-serialize.js"></script>
       <script>
       document.querySelector('.btn').addEventListener('click', () => {
           // 参数1：要获取哪个表单数据, 参数2：配置对象
           const form = document.querySelector('.example-form')
           const data = serialize(form, {hash: true, empty: true})
           // 获取的属性名来自于 input 标签的 name
           console.log(data)
       })
   	</script>
   </body>
   ```


【[案例 - 用户登录 - 升级](#用户登录)】

---

### Bootstrap 弹框

要先**引入 bootstrap.css 和 bootstrap.js**

功能：不离开当前页面，显示单独内容弹框，供用户操作。

通过属性控制弹框显示或隐藏：

- 步骤：

1. 准备**弹框标签**，确认结构。
2. 通过**自定义属性**，控制弹框的显示和隐藏。

- 说明：

  想要使用 bootstrap 的 modal 弹框，需要添加 modal 类名，且默认隐藏（display: none）

  想绑定按钮与 bootstrap 的弹框的话，要使用 bootstrap 提供的自定义属性：

  显示弹框绑定：**data-bs-toggle**（点击出现什么类型的弹框）和 **data-bs-target**（关联哪一个弹框盒子）

  ```html
  <head>
      <!-- 引入bootstrap.css -->
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet">
  </head>
  <body>
      <!-- 为要绑定的按钮添加 data-bs-toggle 与 data-bs-target -->
      <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target=".my-box">
          显示弹框
      </button>
      <!-- 以下由 bootstrap 官网粘贴 -->
      <!-- 防止多个 modal 弹窗，方便定位添加类名 my-box（自己取名） -->
      <div class="modal my-box" tabindex="-1">
          <div class="modal-dialog">
          <!-- 下文隐藏，直接官网复制即可 -->
          </div>
      </div>
      <!-- 引入bootstrap.js -->
    	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.min.js"></script>
  </body>
  ```

  隐藏弹框绑定：**data-bs-dismiss**（点击按钮隐藏弹框）

  ```html
  <!-- 这是官网复制的写好的，重点看里面的 data-bs-dismiss 可以点击就关闭弹框 -->
  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
  ```

通过 JS 控制弹窗或隐藏：

- 步骤：

1. 创建弹框对象（使用 new），使用 bootstrap 的对象方法 **Modal**( )，**将弹窗作为参数传入**

2. 调用弹框对象内置方法：**show**( ) 和 **hide**( )，对应显示和隐藏弹框

   ```html
   <body>
       <button type="button" class="btn btn-primary edit-btn">
       	编辑姓名
   	</button>
       <!-- 以下由 bootstrap 官网粘贴 -->
       <div class="modal name-box" tabindex="-1">
           <!-- 略去大部分 -->
           <div class="modal-body">
               <form action="">
                   <span>姓名：</span>
                   <input type="text" class="username">
               </form>
           </div>
           <!-- 略去大部分 -->
       </div>
       <!-- 引入bootstrap.js -->
       <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.min.js"></script>
       <script>
           // 创建弹框对象
           const modalDom = document.querySelector('.name-box')
           // 将弹窗传入就得到了和弹窗盒子对应的弹窗对象
           const modal = new bootstrap.Modal(modalDom)
           // 点击按钮
           document.querySelector('.edit-btn').addEventListener('click', () => {
               // 输入框默认姓名
               document.querySelector('.username').value = '默认姓名'
               // 展示弹框
               modal.show()
           })
           // 点击保存按钮，先隐藏弹框
           document.querySelector('.save-btn').addEventListener('click', () => {
               // 获取用户输入姓名
               const username = document.querySelector('.username').value
               console.log('模拟把姓名保存到服务器上', username)
               // 隐藏弹框
               modal.hide()
           })
       </script>
   </body>
   
   ```

因此，**想点击关闭直接关闭弹窗就用属性控制，想在关闭前获取一些信息，就用 JS 控制**。

【[案例 - 图书管理](#图书管理)】

---

### Bootstrap 限时提示框

功能：效果类似下面案例的绿色部分，用于提示用户，很快就会消失。

- html 中使用

  只要添加类名：toast，就可以显示效果，data-bs-delay 表示几秒后消失。

  ```html
  <div class="toast" data-bs-delay="15000">提示框内容</div>
  ```

- 在 js 中使用的步骤：

1. 创建提示框对象（使用 new），使用 bootstrap 的对象方法 **Toast**( )，**将提示框作为参数传入**

2. 调用弹框对象内置方法：**show**( )，显示提示框。

   ```javascript
   // 获取标签
   const toastDom = document.querySelector('css选择器')
   // 创建 Toast 对象
   const toast = new bootstrap.Toast(toastDom)
   // 显示提示框
   toast.show()
   ```

【[案例 - 个人信息设置](#个人信息设置)】

---

### 上传图片文件

上传图片文件的话传入的参数不再是 JSON 字符串，而是 form-data 表单，需要使用 new FormData( ) 创建对象，再使用 append( ) 将图片追加到表单，再上传到服务器。

- 步骤：

1. 获取文件元素，使用事件监听 **change**，用 **e.target.files** 可以获得上传的文件伪数组，单个文件就用 e.target.files[0]。
2. 使用 **new FormData( )** 创建表单对象，使用 **对象.append( 参数名, 值 )** 转化为可以上传到服务器的形式。这个参数名要看接口文档怎么规定。
3. 正常使用 'post' + data{} 上传图片文件。

- 代码：

  ```html
  <body>
      <!-- 文件选择元素 -->
      <input type="file" class="upload">
      <img src="" alt="" class="my-img">
      <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
      <script>
          // 文件选择元素 - 使用 change 改变事件
          document.querySelector('.upload').addEventListener('change', e => {
              console.log(e.target)                     // <input type="file" class="upload">
              console.log(e.target.files)               // FileList 伪数组
              console.log(e.target.files[0])            // 用户上传的图片文件
              // 使用 FormData 携带图片文件
              const fd = new FormData()
              // img 为接口文档规定
              fd.append('img', e.target.files[0])
              axios({
                  url: 'http://hmajax.itheima.net/api/uploadimg',
                  method: 'post',
                  data: fd
              }).then(result => {
                  // 上传成功后的 url 网址
                  const imgUrl = result.data.data.url
                  document.querySelector('.my-img').src = imgUrl
              })
          })
      </script>
  </body>
  ```

- 小案例：更换背景图

  ```javascript
  document.querySelector('.bg-ipt').addEventListener('change', e => {
      const fd = new FormData()
      fd.append('img', e.target.files[0])
      axios({
          url: 'http://hmajax.itheima.net/api/uploadimg',
          method: 'post',
          data: fd
      }).then(result => {
          const imgUrl = result.data.data.url
          // 更改背景图片
          document.body.style.backgroundImage = `url(${imgUrl})`
          // 把 url 地址保存在本地
          localStorage.setItem('bgImg', imgUrl)
      })
  })
  const bgUrl = localStorage.getItem('bgImg')
  bgUrl && (document.body.style.backgroundImage = `url(${bgUrl})`)
  ```

【[案例 - 个人信息设置](#个人信息设置)】

---

### [源码] XHR 对象 - 查询/提交

**XMLHttpRequest (XHR) 对象** 用于与服务器交互。是一种原生服务器通信方式

先**创建 XML 对象**，使用 **对象.open( )** 方法写入接口文档规定的方法与 url，使用 **loadend** 事件监听，最后使用 **对象.send( )** 方法.

1. **使用 XHR**：

   （ <a id='loadend'>loadend</a> 事件用于接收响应结果，无论成功与否都会执行回调函数）

   ```javascript
   const xhr = new XMLHttpRequest()
   xhr.open('请求方法', '请求url网址')
   xhr.addEventListener('loadend', () => {
       // loadend 事件接收响应结果
       console.log(xhr.response)
   })
   // 发送请求到服务器
   xhr.send()
   ```

- 示例：从服务器获取省份列表

  ```html
  <p class="my-p"></p>
  <script>
      const xhr = new XMLHttpRequest()
      xhr.open('get', 'http://hmajax.itheima.net/api/province')
      xhr.addEventListener('loadend', () => {
          // loadend 事件接收响应结果
          console.log(xhr.response)   			// 返回的是 JSON 字符串
          const data = JSON.parse(xhr.response)	// 转化为对象
          console.log(data)           			// 省份数组
          document.querySelector('.my-p').innerHTML = data.list.join('<br>')
      })
      // 发送请求到服务器
      xhr.send()
  </script>
  ```

2. **查询参数**：在 URL 后接 ? 放上参数名=参数值，多个参数用 & 连接。

- 示例：

  ```html
  <p class="my-p"></p>
  <script>
      const xhr = new XMLHttpRequest()
    	// ? 后接参数  
      xhr.open('get', 'http://hmajax.itheima.net/api/city?pname=黑龙江省')
      xhr.addEventListener('loadend', () => {
          console.log(xhr.response)   			// 返回的是 JSON 字符串
          const data = JSON.parse(xhr.response)   // 转化为对象
          console.log(data)           			// 城市数组
          document.querySelector('.my-p').innerHTML = data.list.join('<br>')
      })
      xhr.send()
  </script>
  ```

- **参数转化 URL 查询格式字符串**

  【简写为 urls】

  对于多个参数，可以使用 **new URLSearchParams** ( {多个查询参数} )，然后使用 **对象.toString( )** 方法将参数转化为 URL 后的拼接形式

  ```javascript
  const paramsObj =  new URLSearchParams({
      参数名1: 值1，
      参数名2: 值2
  })
  const queryString = paramsObj.toString()
  ```
  
  补充：还可以借助 new URLSearchParams( ) 解析浏览器 URL 地址 ? 后的内容，看例子
  
  ```javascript
  // 获取 URL ?后的 id
  const paramStr = location.search			// paramStr = id=4384a488-f49c-44fb-b968-be54d8215212
  const params = new URLSearchParams(paramStr)
  params.forEach((value, key) => {
      console.log(value, key)					// 4384a488-f49c-44fb-b968-be54d8215212 id
  })
  ```

【[案例 - 地区查询 - XHR 版](#XHR)】

3. **数据提交**

   请求头设置：**Content-Type: application/json**，以告知服务器上传内容为 JSON 字符串，请求体携带 JSON 字符串，通过 **对象.send( )** 发出请求。

   ```html
   <button class="reg-btn">注册用户</button>
   <script>
       document.querySelector('.reg-btn').addEventListener('click', () => {
           // 创建 XMLHttpRequest 对象
           const xhr = new XMLHttpRequest()
           xhr.open('post', 'http://hmajax.itheima.net/api/register')
           xhr.addEventListener('loadend', () => {
               console.log(xhr.response)       // 注册成功
           })
           // 设置请求头 - 告知服务器内容类型是 JSON 字符串
           xhr.setRequestHeader('Content-Type', 'application/json')
           const user = {
               username: 'crazytieniu',
               password: '1767577'
           }
           // 把对象转化为 JSON 字符串
           const userStr = JSON.stringify(user)
           xhr.send(userStr)
       })
   </script>
   ```

---

### [源码] Promise 对象异步处理

异步任务就是代码要等，js不等，压到队列里排队，先执行别的代码，排到它了再回头执行。

Promise 对象用来管理一个**异步任务**操作完成（成功或失败）后，管理它的**结果值**

- 好处：逻辑清晰，了解 axios 函数内部运作机制，能解决回调函数地狱问题。

- 步骤：先 new Promise()，括号内传入回调函数，回调参数为 resolve 和 reject，用于接收异步任务成功结果和失败结果，回调函数内放异步任务。后面用 对象.then( ).catch( ) 接收前面 resolve 和 reject 的成功与失败的结果。

- 难懂的话看代码：

  ```javascript
  // 状态为 pending
  const p = new Promise((resolve, reject) => {
      // promise 对象一旦创建，回调函数代码立即执行。等待执行异步代码
      // 并给异步代码绑定下面的 then 和 catch
      setTimeout(() => {
          // resolve('模拟 ajax 请求 - 成功结果')
          reject(new Error('模拟 ajax 请求 - 失败结果'))
      }, 2000)
  })
  // 接收结果
  p.then(result => {
      console.log(result)                         // 模拟 ajax 请求 - 成功结果
  }).catch(error => {
      console.log(error)                          // 模拟 ajax 请求 - 失败结果
  })
  ```
  
- Promise 的三种状态

  **Promise 对象被 new 出来时，他会有一个状态：pending（待定）**

  **一旦它管理的异步任务有了结果，是成功结果就执行 resolve( )，修改状态为 fulfilled（已兑现），执行 then() 的功能，**

  **是失败结果就执行 reject( )，修改状态为 rejected（已拒绝），执行 catch() 的功能，这个状态一旦确定就不会变了。即要么成功要么失败。**

- 示例：获取省份列表显示在网页上，访问失败显示 404

  ```html
  <p class="my-p"></p>
  <script>
      // 创建 Promise 对象
      const p = new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest()
          xhr.open('get', 'http://hmajax.itheima.net/api/province1')
          xhr.addEventListener('loadend', () => {
              // xhr 通过响应状态码判断响应成功还是失败
              // status 响应状态码 在2开头即响应成功
              if (xhr.status >= 200 && xhr.status < 300) {
                  resolve(JSON.parse(xhr.response))
              } else {
                  // 错误结果一般用 Error 返回
                  reject(new Error(xhr.response))
              }
          })
          xhr.send()
      })
      p.then(result => {
          console.log(result)
          document.querySelector('.my-p').innerHTML = result.list.join('<br>')
      }).catch(error => {
          console.log(error)
          // 错误对象要用 console.dir 详细打印
          console.dir(error)
          // 错误也显示在页面上
          document.querySelector('.my-p').innerHTML = error.message
      })
  </script>
  ```

---

### [源码] 封装：Promise + XHR

在了解了上面的 XHR 与 Promise 后，会发现下面的代码就是 axios 的功能。

**对应 axios 那里的三种交互：不传查询参数，传参数查询，数据提交三种。**

- 封装函数：

  ```javascript
  // 接收配置对象
  function myAxios(config) {
      return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest()
          // [传参查询] 做判断，有无 params 参数传入
          if (config.params) {
              // 用 URLSearchParams 转换成 URL 格式的字符串
              const paramsObj = new URLSearchParams(config.params)
              const queryString = paramsObj.toString()
              // 把查询参数拼接在 URL 问号后
              config.url +=  `?${queryString}`
          }
          // 因为封装了函数，请求方法从配置文件得来，默认为 get
          xhr.open(config.method || 'get', config.url)
          xhr.addEventListener('loadend', () => {
              // 响应成功
              if (xhr.status >= 200 && xhr.status < 300) {
                  // 服务器返回 JSON字符串 => 对象
                  resolve(JSON.parse(xhr.response))
              } else {
                  reject(new Error(xhr.response))
              }
          })
          // [数据提交] 判断有无 data 选项
          if (config.data) {
              // 数据提交
              const jsonStr = JSON.stringify(config.data)
              // 设置请求头
              xhr.setRequestHeader('Content-Type','application/json')
              xhr.send(jsonStr)
          } else {
              // 非数据提交的情形，发送
              xhr.send()
          }
      })
  }
  ```

1. **不含查询参数**：基于 Promise + XHR 封装 MyAxios 函数，用于获取省份列表展示。

   ```html
   <p class="my-p"></p>
   <script>
       myAxios({
           url: 'http://hmajax.itheima.net/api/province1'
       }).then(result => {
           console.log(result)     // {list:[], message:"获取省份成功"}
           document.querySelector('.my-p').innerHTML = result.list.join('<br>')
       }).catch(error => {
           console.log(error)      // error.message: <h1>404 Not Found</h1>
           document.querySelector('.my-p').innerHTML = error.message
       })
   </script>
   ```

2. **传查询参数**：传递省份名与城市名，用于获取地区名

   ```html
   <p class="my-p"></p>
   <script>
   
       myAxios({
           url: 'http://hmajax.itheima.net/api/area',
           params: {
               pname: '黑龙江省',
               cname: '鸡西市'
           }
       }).then(result => {
           console.log(result)     // {list:[], message:"获取城市成功"}
           document.querySelector('.my-p').innerHTML = result.list.join('<br>')
       }).catch(error => {
           console.log(error)      // error.message: <h1>404 Not Found</h1>
           document.querySelector('.my-p').innerHTML = error.message
       })
   </script>
   ```

3. **上传数据**：请求方法为 post，传递数据为 data 对象，data 对象

   ```html
   <button class="reg-btn">注册用户</button>
   <script>
   	document.querySelector('.reg-btn').addEventListener('click', () => {
           myAxios({
               url: 'http://hmajax.itheima.net/api/register',
               method: 'post',
               data: {
                   username: 'crazytieniu',
                   password: '1767577'
               }
           }).then(result => {
               console.log(result)     // 注册成功
           }).catch(error => {
               console.log(error)      // 账号被占用
           })
       })
   </script>
   ```

【[案例 - 天气预报](#天气预报)】

---

### Promise 链式调用

1. 同步与异步

   同步代码就是一行一行执行的代码，异步代码就是需要等待回调的代码，触发后执行回调函数。AJAX 是异步代码。

2. **回调函数地狱**

   例如获得省市区的下拉列表功能，要嵌套三层 axios 的回调函数。

   所谓**回调函数地狱**，就是在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱，缺点为可读性差，异常无法捕获，耦合性严重，牵一发动全身。

   ```javascript
   axios({url: 'http://hmajax.itheima.net/api/province'}).then(result => {
       // 获取第一个省份的名字放到框内展示
       const pname = result.data.list[0]
       document.querySelector('.province').innerHTML = pname
       axios({url: 'http://hmajax.itheima.net/api/city', params: { pname }}).then(result => {
           // 获取第一个城市的名字放到框内展示
           const cname = result.data.list[0]
           document.querySelector('.city').innerHTML = cname
           axios({url: 'http://hmajax.itheima.net/api/area', params: { pname , cname }}).then(result => {
                   // 获取第一个地区的名字放到框内展示
                   const areaname = result.data.list[0]
                   document.querySelector('.area').innerHTML = areaname
           })
       })
   }).catch(error => {
       console.dir(error)  // 异常无法捕获
   })
   ```

   可以使用 Promise 链式调用解决回调函数地狱问题，

3. **Promise 链式调用**

   **依靠 Promise 的 then( ) 方法**返回新生成的 Promise 对象的特性，就可以串联下一个任务，直到结束。

- 核心思想：

  **axios 会返回 Promise**（之前用 XHR 和 Promise 封装 axios 功能，因此才能用 Promise 的 then 和 catch）

  ```javascript
  // 创建一个 Promise 对象，回调函数作为参数传入
  const p = new Promise((resolve, reject) => {
      // 模拟获取省份
      setTimeout(() => {
      	resolve('黑龙江省')
      }, 2000)
  })
  // p.then() 接收 '黑龙江省' 的结果，同时返回一个新的 Promose 对象
  p2 = p.then(result => {
      console.log(result)
      // 创建 Promise 对象 
      return new Promise((resolve, reject) => {
      // 模拟获取城市
          setTimeout(() => {
  			resolve('哈尔滨市')
      }, 2000)
      })
  })
  // 因为上面返回新对象，用 p2 接收，p2 是 Promise 对象，又可以用 then 方法
  // p2.then() 接收 哈尔滨市' 的结果。
  p2.then(result => {
  	console.log(result)
  })
  // p 与 p2 是两个截然不同的个对象
  console.log(p === p2)     // false, then() 返回的是新对象
  ```

- 用 Promise 链式调用解决回调函数地狱

  **用 then( ) 返回 Promise 对象**，还是用上面获取省市区的例子

  ```javascript
  // 这里是因为获取地区时 pname 不在作用域内，所以在这里定义全局变量，通过赋值访问到 pname
  let pname = ''
  axios({url: 'http://hmajax.itheima.net/api/province'}).then(result => {
      // 接收省份
      pname = result.data.list[0]
      document.querySelector('.province').innerHTML = pname
      // 想嵌套 axios 就 return, 因为返回了 Promise 对象，可以在外面接收
      return axios({url: 'http://hmajax.itheima.net/api/city', params: { pname }})
  }).then(result => {
      // 接收城市
      const cname = result.data.list[0]
      document.querySelector('.city').innerHTML = cname
      // 当前作用域没有 pname，所以要在最上面定义一个全局的 pname
      return axios({url: 'http://hmajax.itheima.net/api/area', params: {pname, cname}})
  }).then(result => {
      // 获取地区
      const areaname = result.data.list[0]
      document.querySelector('.area').innerHTML = areaname
  })
  ```


---

### async 函数与 await

**async 函数**是用 async 关键字声明的函数，在 async 函数内，**使用 await 关键字取代 then( )**，等待**获取 Promise 对象成功状态**的结果值。

await 关键字遇到异步任务会暂停执行，直到返回成功结果。

- 使用示例：

  ```javascript
  async function getData() {
      // 使用 await 关键字获取 Promise 对象成功结果
      // 获取省份
      const pObj = await axios({url: 'http://hmajax.itheima.net/api/province'})
      const pname = pObj.data.list[0]
      // 获取城市
      const cObj = await axios({url: 'http://hmajax.itheima.net/api/city', params: {pname}})
      const cname = cObj.data.list[0]
      // 获取地区
      const aObj = await axios({url: 'http://hmajax.itheima.net/api/area', params: {pname, cname}})
      const aname = aObj.data.list[0]
  
      document.querySelector('.province').innerHTML = pname
      document.querySelector('.city').innerHTML = cname
      document.querySelector('.area').innerHTML = aname
  }
  getData()
  ```

- 使用 try...catch 捕获错误

  用 **try{ }** 包裹可能出错的代码，在 try 的括号外用 **catch{ }** 捕获错误，如果 try 里的代码发生了错误，那么 try 中剩余的代码就不执行了

  ```javascript
  async function getData() {
      try {
          const pObj = await axios({url: 'http://hmajax.itheima.net/api/province'})
          const pname = pObj.data.list[0]
          const cObj = await axios({url: 'http://hmajax.itheima.net/api/city', params: {pname}})
          const cname = cObj.data.list[0]
          const aObj = await axios({url: 'http://hmajax.itheima.net/api/area1', params: {pname, cname}})
          const aname = aObj.data.list[0]
          document.querySelector('.province').innerHTML = pname
          document.querySelector('.city').innerHTML = cname
          document.querySelector('.area').innerHTML = aname
      } catch (error) {
      	console.dir(error)      // 得到错误信息对象
      }
  }
  getData()
  ```


---

### 事件循环

在 JS 篇谈过一嘴，请在 JS 篇使用 Ctrl + F 搜索 “事件循环”

- 事件循环的目的：为了异步耗时任务不阻塞 JS 引擎。

- 执行过程：JS 会先执行同步代码，异步代码会交给宿主环境（浏览器）执行，浏览器执行完异步代码后，会把**回调函数**放入队列中等待，同步代码执行完且异步代码的回调函数等待结束，就放入执行栈中执行。

- 练习：

  ```javascript
  console.log(1)
  setTimeout(() => {
  	console.log(2)
  }, 0)
  function myFn() {
  	console.log(3)
  }
  function ajaxFn() {
      const xhr = new XMLHttpRequest()
      xhr.open('GET', 'http://hmajax.itheima.net/api/province')
      xhr.addEventListener('loadend', () => {
      	console.log(4)
      })
      xhr.send()
  }
  for (let i = 0; i < 1; i++) {
  	console.log(5)
  }
  ajaxFn()
  document.addEventListener('click', () => {
  	console.log(6)
  })
  myFn()
  ```

  执行结果是 1 5 3 2 4，点击出现 6
  
- 宏任务与微任务

  在 ES6 后引入了 Promise 对象，让 JS 引擎也可以发起异步任务

  异步任务分为：**宏任务**（由浏览器执行的异步代码）和微任务（由 JS 引擎执行的异步代码），**微任务**例如 Promise.then( )，Promise 本身是同步的，而 then 和 catch **回调函数**是异步的。

  ```javascript
  console.log(1)
  setTimeout(() => {
      console.log(2)
      const p = new Promise(resolve => resolve(3))
      p.then(result => console.log(result))
  }, 0)
  const p = new Promise(resolve => {
      setTimeout(() => {
      	console.log(4)
      }, 0)
      resolve(5)
  })
  p.then(result => console.log(result))
  const p2 = new Promise(resolve => resolve(6))
  p2.then(result => console.log(result))
  console.log(7)
  ```

  流程为：**输出 1**，setTimeout( ) 交给浏览器，发现倒计时 0 秒，回调函数推入宏任务队列。到 Promise，是同步任务，立刻执行回调函数，但回调函数内是 setTimeout( ) 发给浏览器，倒计时 0 秒，setTimeout( ) 的回调推入宏任务队列，Promise 执行成功，设置为 5，出栈。进入 then 方法，是异步任务，因为已经成功了，推入微任务队列。进入下一个 Promise，执行成功，设置为 6,。进入第二个 then 方法，是异步任务，因为已经成功所以推入微任务队列。到了最后，**输出 7**。同步任务执行完成，**先执行微任务队列**，此时微任务队列有两个内容，压入栈执行，**输出 5  6**。微任务队列清空，进入宏任务队列，入栈，执行回调函数，**输出 2**，Promise 成功，结果为 3，then 方法推入微任务队列，宏任务队列中的 setTimeout( ) 执行完毕，出栈。进入微任务队列，**输出 3**。最后进入宏任务队列，入栈，**输出 4**，出栈结束。

  执行结果是 ：1 7 5 6 2 3 4 （以上为经典面试题）

---

### Promise.all

Promise.all 静态方法，用于**合并多个 Promise 对象**，等待所有被合并的 Promise **同时完成**或者失败，执行后续逻辑。

- 核心：

  ```javascript
  const p = Promise.all( [ Promise 对象, ..., Promise 对象 ] )
  p.then(result => {
      // 所有 Promise 对象 都成功返回结果
  }).catch(error => {
      // 只要有 Promise 对象 失败
  })
  ```

- 示例：一口气获取北上广深的天气数据渲染到页面上。

  ```javascript
  // code：北京-110100 上海-310100 广州-440100 深圳-440300
  // 请求城市天气
  const bjPromise = axios({url: 'http://hmajax.itheima.net/api/weather', params: {city: '110100'}})
  const shPromise = axios({url: 'http://hmajax.itheima.net/api/weather', params: {city: '310100'}})
  const gzPromise = axios({url: 'http://hmajax.itheima.net/api/weather', params: {city: '440100'}})
  const szPromise = axios({url: 'http://hmajax.itheima.net/api/weather', params: {city: '440300'}})
  // 合并多个 Promise 对象
  const p = Promise.all([bjPromise, shPromise, gzPromise, szPromise])
  p.then(result => {
      console.log(result)   // 返回数组，顺序与发送顺序一致
      const htmlStr = result.map(item => {
  		return `<li>${item.data.data.area} --- ${item.data.data.weather}</li>`
      }).join('')
  	document.querySelector('.my-ul').innerHTML = htmlStr
  }).catch(error => {
  	console.dir(error)
  })
  ```

【[案例 - 商品分类](#商品分类)】

【[案例 - 省份菜单](#省份菜单)】

---

### axios 请求/响应拦截器

这部分请结合 AJAX 阶段案例来看。

1. 请求拦截器

   **请求拦截器使请求发起前会执行一个函数，函数中对请求参数进行额外设置。（比如携带 token）**

- 需求：为登录后的页面设置用户昵称，昵称要从服务器端获取，重点在于**请求参数**，传参方式为请求头，值为身份令牌即 token。

- 格式：

  ```javascript
  axios({
      url: '目标资源地址',
      headers: {
          // 后端要求格式为: Bearer[空格]token值
          Authorization: `Bearer ${localStorage.getItem('token')}`
      }
  })
  ```

  因为接口很多，都需要携带 token 令牌字符串，所以可以使用 **axios 请求拦截器** 统一设置公共 header 选项

- axios 请求拦截器

  **发送请求之前**，出发的配置函数，对请求参数进行额外配置。

  ```javascript
  // 添加请求拦截器
  axios.interceptors.request.use(function (config) {
      // 在发送请求前 统一携带 token 令牌字符串在请求头上
      const token = localStorage.getItem('token')
      // 从本次配置文件的请求头上添加参数名
      token && (config.headers.Authorization = `Bearer ${token}`)
      return config;
  }, function (error) {
      // 下面反而用的很少，不用管
      return Promise.reject(error)
  });
  ```

2. 响应拦截器

   **响应拦截器会对响应结果执行一个函数做出拦截，即响应在 then / catch 之前，触发拦截函数，函数中对响应结果做统一处理。**

- 需求：

  **对相应结果进行操作**。

  对身份验证失败（响应状态码 401）时，做统一的判断并处理，而不是每次都单独判断。

  且响应成功时，服务器返回结果是被包裹在一个大对象中的，每次都要 response.data 才能定位到服务器返回的结果，为了使所有 axios( ).then( ) 的 result 直接接收到服务器返回结果，需要用到响应拦截器。

- 代码：

  ```javascript
  // 添加响应拦截器
  axios.interceptors.response.use(function (response) {
      // 2xx 范围内的状态码都会触发该函数。
      const result = response.data
    	// 这里相当于传入 then 的回调函数中 
      return result;
  }, function (error) {
      // 超出 2xx 范围的状态码都会触发该函数。这里统一对 401 身份验证失败情况做出处理
      // 这里的 ? 可以避免报错，如果前面没有值后面就不执行了
      if (error?.response?.status === 401) {
          alert('身份验证失败，请重新登陆')
          // 清空本地存储
          localStorage.clear()
          // 返回登录页
          location.href = '../login/index.html'
      }
      return Promise.reject(error);
  });
  ```

AJAX 阶段案例：【[头条新闻管理](#头条新闻管理)】

---

## Node.js

Node.js 是一个跨平台 JavaScript 运行环境。用于**前端工程化**，

- Node.js 的安装：建议安装 16.19.0 版本
- 打开继承终端：win + S 搜索 cmd 或 在 vscode 内左侧菜单右键 - 在集成终端中打开。使用 node - v 查看 nodejs 版本
- 新建 js 文件并在 node 环境执行：**node + xxx.js**
- **node.js 没有 BOM 和 DOM**
- 模块的概念：模块类似插件，封装了方法和属性。

### fs 模块

fs 模块封装了与**本机文件系统进行交互**的方法和属性。

- 语法：

  ```javascript
  const fs = require('fs')					// 加载模块对象，fs 为模块标识符
  // 写入文件内容
  fs.writeFile('文件路径', '写入内容', err => {
  	// 写入后的回调函数  
  })
  // 读取文件内容
  fs.readFile('文件路径', (err, data) => {	 // data 是文件内容的 Buffer 数据流
  	// 读取后的回调函数  
  })
  ```

- 示例：

  ```javascript
  const fs = require('fs')
  // 写入文件
  fs.writeFile('./test.txt', 'hello, Node.js', (err) => {
      if (err) console.log(err)
      else console.log('写入成功')
  })
  // 读取文件
  fs.readFile('./test.txt', (err, data) => {
      if (err) console.log(err)
      else console.log(data.toString())		// data 是16进制，用 toString() 方法转化为字符串
  })
  ```

---

### path 模块

- 在 node,js 中，建议使用**绝对路径**，使用绝对路径需要使用 **__dirname** 内置变量来获得当前模块目录的绝对路径，针对 windows 与 mac 系统的文件路径分隔符不一样，使用 **path.join( )** 会使用特定平台的分隔符。

- 使用绝对路径的解释：

  例如同级目录下有 gg文件夹 与 test.txt，gg文件夹内有 test.js 文件，此文件内容如下：用于读取上级的 test.txt 文件

  ```javascript
  const fs = require('fs')
  fs.readFile('../test.txt', (err, data) => {
      if (err) console.log(err)
      else console.log(data.toString())
  })
  ```

  在终端里

  ```bash
  PS 路径略\gg> node test.js
  ```

  可以读取文件正确运行，但是如果在上级路径使用终端，虽然路径正确，但找不到文件：

  ```bash
  PS 路径略> node gg/test.js
  ```

  因为虽然能找到 js 文件，但运行 js文件的路径中的 ".." 是以终端路径为起点的，而不是 js 路径为起点。为了避免这种情况要做**路径处理**，使用绝对路径。

  ```javascript
  const fs = require('fs')
  // 引入 path 模块对象
  const path = require('path')
  
  console.log(__dirname)              		// 会得到这个 js 文件所在的绝对路径
  // 调用 path.join() 配合 __dirname 组成目标文件的绝对路径
  fs.readFile(path.join(__dirname, '../test.txt'), (err, data) => {
      if (err) console.log(err)
      else console.log(data.toString())
  })
  ```

  【案例 - **压缩**前端 HTML】
  
  把回车符（\r）和换行符（\n）去掉后写入到新 html 文件中
  
  ```javascript
  const fs = require('fs')
  const path = require('path')
  // 路径会自动用 / 连接
  fs.readFile(path.join(__dirname, 'public/index.html'), (err, data) => {
    if (err) console.log(err)
    else {
      const htmlStr = data.toString()
      // 正则表达式 - 处理字符串
      const resultStr = htmlStr.replace(/[\r\n]/g, '')
      // 写入
      fs.writeFile(path.join(__dirname, 'dist/index.html'), resultStr, err => {
        if (err) console.log(err)
        else console.log('写入成功')
      })
    }
  })
  ```

---

### http 模块

1. URL 端口

- URL 端口号：即 URL 网址上 : 后接的数字，标记服务器里不同功能的服务程序，**http 协议默认访问 80 端口**。0 ~ 1023 和一些特定端口号被占用，应避开这些端口编写服务程序
- 常见端口号：[web 服务] 80，3000，8080	[数据库服务] 3306

2. **http 模块**

- 语法

  ```javascript
  // 加载 http 模块，创建 web 服务对象
  const http = require('http')
  const server = http.createServer()
  // 监听 request 请求事件，设置响应头和响应体
  // req 接受本次请求参数
  server.on('request', (req, res) => {
      // 设置响应头内容类型：普通文本及中文编码
      res.setHeader('Content-Type', 'text/plain;charset=utf-8')
      res.end('原神！启动！')
  })
  // 配置端口号并启动 web 服务
  server.listen(3000, () => {
      console.log('原神已经可以启动')
  })
  ```
  
  使用 node.js 运行以上代码后，浏览器输入（**localhost 表示本机域名**）
  
  ```
  http://localhost:3000
  ```
  
  即可启动 web 服务，网页会输出 “原神！启动！”
  
- 示例：网页内容写在了 dist/index.html 文件下，在 dist 文件夹同级创建一个 js 文件，用于启动 web 服务

  ```javascript
  const http = require('http')
  const fs = require('fs')
  const path = require('path')
  const server = http.createServer()
  server.on('request', (req, res) => {
      // 使用 req.url 获取请求资源路径，并读取 index.html 里字符串内容返回给请求方
      if (req.url === '/index.html') {
          fs.readFile(path.join(__dirname, 'dist/index.html'), (err, data) => {
              if (err) console.log(err)
              else {
                  // 设置响应内容类型为 HTML 超文本字符串
                  res.setHeader('Content-Type', 'text/html;charset=utf-8')
                  res.end(data.toString())
              }
          })
      } else {
          res.setHeader('Content-Type', 'text/html;charset=utf-8')
          res.end('你要访问的资源路径不存在')
      }
  })
  server.listen(8080, () => {
      console.log('web 服务启动成功')
  })
  ```

  使用 node 启动 web 服务后，浏览器输入

  ```
  http://localhost:8080/index.html
  ```

  即可查看网页。

---

### 模块化 - 两个标准

需求：因为每个模块都头独立的作用域，所以如果在某模块定义了属性或方法，在其他模块想要使用

1. **CommonJS 标准（默认支持）**

   **一般应用在 Node.js 项目环境中**

- 语法：

   **导出：module.exports** = {}		**导入：require**( '模块名或路径' ) 【内置模块名写模块名字，自定义模块写路径】

- 示例：数组求和功能写在了 test/utils.js 内，test/index.js 想要启动 utils 内定义的属性与方法

  test / utils.js 的内容

  ```javascript
  const baseURL = 'http://baidu.com'
  const getArraySum = arr => arr.reduce((sum, val) => sum += val, 0)
  module.exports = {
      // 对外属性名1: 值
      url: baseURL,
      // 对外属性名2: 值
      arraySum: getArraySum
  }
  ```

  test / index.js 的内容

  ```javascript
  const obj = require('./utils.js')
  console.log(obj)
  // 使用数组求和方法
  const result = obj.arraySum([5, 1, 2, 3])
  console.log(result)
  ```

  用 node 启动 index.js 即可看到：

  ```
  { url: 'http://baidu.com', arraySum: [Function: getArraySum] }
  11
  ```


2. **ECMAScript 标准 **

   **一般应用在前端工程化项目中**
   
   node.js 默认支持的模块标准是上面的 CommonJS 标准，**要使用 ECMAScript 标准需要在模块同级文件夹下使用 package.json 文件**

- 语法：

   需要**在运行模块所在文件夹新建 package.json 文件，并设置 {"type": "module"}**

   **导出：export default** {}		**导入：import** 变量名 **from** '模块名或路径'

- 示例：数组求和功能写在了 test/utils.js 内，test/index.js 想要启动 utils 内定义的属性与方法

  test / package.json 的内容

  ```json
  {"type": "module"}
  ```

  test / utils.js 的内容

  ```javascript
  const baseURL = 'http://baidu.com'
  const getArraySum = arr => arr.reduce((sum, val) => sum += val, 0)
  export default {
      // 对外属性名1: 值
      url: baseURL,
      // 对外属性名2: 值
      arraySum: getArraySum
  }
  ```

  test / index.js 的内容

  ```javascript
  import obj from './utils.js'
  console.log(obj)
  // 使用数组求和方法
  const result = obj.arraySum([5, 1, 2, 3])
  console.log(result)
  ```

  用 node 启动 index.js 即可看到：

  ```
  { url: 'http://baidu.com', arraySum: [Function: getArraySum] }
  11
  ```

3. **ECMAScript 标准 - 命名导出和导入**


- 语法：

  需要**在运行模块所在文件夹新建 package.json 文件，并设置 {"type": "module"}**
  
  **导出：export 修饰定义句**		**导入：import** 同名变量 **from** '模块名或路径'
  
- 示例：数组求和功能写在了 test/utils.js 内，test/index.js 想要启动 utils 内定义的属性与方法

  test / package.json 的内容

  ```json
  {"type": "module"}
  ```

  test / utils.js 的内容

  ```javascript
  export const baseURL = 'http://baidu.com'
  export const getArraySum = arr => arr.reduce((sum, val) => sum += val, 0)
  ```

  test / index.js 的内容

  ```javascript
  import {baseURL, getArraySum} from './utils.js'
  console.log(baseURL)
  // 使用数组求和方法
  const result = getArraySum([5, 1, 2, 3])
  console.log(result)
  ```

  用 node 启动 index.js 即可看到：

  ```javascript
  { url: 'http://baidu.com', arraySum: [Function: getArraySum] }
  11
  ```

4. 使用场景：

   如果按需加载，使用命名导出和导入即可，不需要的可以不用写属性或方法名。

   如果全部加载，使用默认导出和导入即可。

---

### 包与 npm 软件包管理器

1. 包

   包即是把模块、代码、其他资料聚合成一个**文件夹**，要求**根目录必须有 package.json 文件**，记录包的名字、入口文件、作者、版本号等。

   **项目包：**主要用于编写项目和业务逻辑

   **软件包：**封装工具和方法进行使用

   **导入软件包时，默认引入是 index.js 模块文件，没有此文件则引入 package.json 中 main 属性指定的模块文件**

- 示例：

  目录结构：{ utils [ lib ( arr.js, str.js ), index.js, package.json ], server.js }

  说明：lib 文件夹封装了软件包工具的方法源代码，index.js 为向外暴露的出口，package.json 为软件包说明清单文件

1. utils / lib / arr.js

   ```javascript
   // 封装数组常用方法
   const getArraySum = arr => arr.reduce((sum, item) => sum += item, 0)
   module.exports = {
   	getArraySum
   }
   ```

2. utils / lib / str.js

   ```javascript
   // 封装字符串常用方法
   const checkUserName = username => {
   	return username.length >= 8
   }
   const checkPassWord = password => {
   	return password.length >= 6
   }
   module.exports = {
   	checkUser: checkUserName,
   	checkPwd: checkPassWord
   }
   ```

3. utils / index.js 导入了两个文件的方法，再统一导出去

   ```javascript
   // 本文件是 utils 工具包的唯一出口 作用：把所有工具模块方法集中起来，统一向外暴露
   // 对象解构赋值
   const { getArraySum } = require('./lib/arr.js')
   const { checkUser, checkPwd } = require('./lib/str.js')
   // 统一导出所有函数
   module.exports = {
   	getArraySum,
   	checkUser,
   	checkPwd
   }
   ```

4. utils / package.json 其中 main 表示这个包的入口

   ```json
   {
       "name": "utils",
       "version": "1.0.0",
       "description": "一个数组和字符串常用工具方法的包",
       "main": "index.js",
       "author": "crazytieniu",
       "license": "CTN"
   }
   ```

5. server.js 里面的 obj 对象接收到的就是 index.js 导出的内容

   ```javascript
   // 目标：导入 utils 软件包，使用里面封装的工具函数
   // 导入文件包时，会找下面的 index.js 文件
   const obj = require('./utils')
   const result = obj.getArraySum([10, 20, 30])
   console.log(result)             		// 60
   ```

---

2. **npm 软件包管理器**

- 使用

  初始化清单文件： **npm init -y** （得到 package.json 文件，有则略过此命令）。下载软件包：**npm i** 软件名称，会在项目文件夹自动创建 **node_modules 文件夹存储软件包文件**与一个 **package-lock.json 文件用来固化软件包版本**。

- 示例：使用 npm 软件包 dayjs 实现一个项目（项目不要用中文路径）

  准备一个项目文件夹，比如 test，test 下有一个空的 server.js ，想引入软件包，使用以下命令：

  ```bash
  npm init -y
  ```

  因为没有 package.json 文件，会生成 package.json 文件，使用 npm 下载 dayjs

  ```bash
  npm i dayjs
  ```

  下载后，在 test 文件夹下多出了 node_modules 文件夹，其下有 dayjs 软件包文件夹和 package-lock.json，test 文件夹下也有多了一个 package-lock.json。下载完毕，接下来是使用。编写 server.js

  ```javascript
  // 内置模块和 npm 下载模块写名字就行
  const dayjs = require('dayjs')
  // 对象.方法()
  const nowDateStr = dayjs().format('YYYY-MM-DD')
  console.log(nowDateStr)        			 // 2023-07-11
  ```

- **安装所有依赖**

  如果从别人手里拿到项目，只有 package.json， package-lock.json 和 server.js，没有软件包，要下载所有依赖。

  ```bash
  npm i
  ```

  使用此命令即可下载所有依赖。

- **npm 全局软件包 nodemon**

  本地软件包：**当前项目内使用**，封装属性和方法，存在于 node_modules

  全局软件包：**本机**所有项目使用，封装命令和工具，存在与系统设置的位置。

  **nodemon 命令**用来取代 node 命令，检测代码更改，自动重启程序。

  安装 nodemon

  ```bash
  npm i nodemon -g
  ```

  运行使用：nodemon + xxx.js，运行后不会关闭，直接修改 server.js 保存直接就回改变执行结果。

---

- 总结：

  ![](./\图片\node包.png)

  | 功能                | 命令              |
  | ------------------- | ----------------- |
  | 执行 js 文件        | node xxx          |
  | 初始化 package.json | npm init -y       |
  | 下载本地软件包      | npm i 软件包名    |
  | 下载全局软件包      | npm i 软件包名 -g |
  | 删除软件包          | npm uni 软件包名  |

---

## Webpack

[webpack 官方中文文档](https://www.webpackjs.com/concepts/)

### webpack 打包步骤

静态模块：编写代码过程的 HTML、CSS、JavaScript 与 图片等固定内容

打包：把静态模块的内容，压缩、整合、转译（前端工程化）

- **webpack 打包步骤：**

1. 准备源码（项目结构内写好源码，导入和导出）

2. **准备相关配置（下载 webpack 和 webpack-cli 到当前项目中，并在 package.json 配置局部自定义命令）**

   ```bash
   # 下载 webpack --save-dev 表示这两个包在开发环境使用
   npm i webpack webpack-cli --save-dev
   ```

   在 package.json 中的 script 选项**添加自定义命令**（build 是自定义的，小写，想叫啥都行）

   ```json
   "scripts": {
       "build": "webpack"
   },
   ```

3. **运行命令（使用 npm run + 自定义命令）**

   ```bash
   npm run build
   ```

   **运行后就会产生 dist 文件夹，里面产生 main.js 文件，用于最终运行项目的代码。**

- 需求：封装 utils 包，校验手机号长度和验证码长度，在 src / index.js 中使用并打包

- 示例：

  新建一个项目，使用以下命令：

  ```bash
  # 初始化，得到 package.json
  npm init -y
  ```

  在项目内新建 src 文件，内有 utils 文件夹和 index.js

  ```javascript
  /* utils / check.js	*/
  // 封装校验手机号长度验证和验证码长度验证的函数
  export const checkPhone = phone => phone.length === 11
  export const checkCode = code => code.length === 6
  
  /* index.js	*/
  // 体验 webpack 打包过程
  import {checkPhone, checkCode} from './utils/check.js'
  // 测试验证
  console.log(checkPhone('13340335319'), checkCode('6666666'))
  ```

  然后下载 webpack，多个软件用空格隔开

  ```bash
  npm i webpack webpack-cli --save-dev
  ```

  下载完成后，项目内会出现 node_modules 文件夹，且 package.json 内容变化和出现新的 package-lock.json

  打开 package.json 在 script 位置添加一行内容："build": "webpack"，表示自定义命令

  ```json
  "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1",
      "build": "webpack"
  },
  ```

  接下来就可以体验运行自定义命令了，终端内输入

  ```bash
  npm run build
  ```

  会在项目根目录生成一个 dist 文件夹，内有一个 main.js 文件，这个文件就是webpack 分析代码后压缩得到的代码产物。

---

### webpack 修改出入口

- 入口

  webpack **默认以 ./ src / index.js 作为入口起点**。所以项目中用到的函数要最终导出到 index.js 内。

  但这个入口可以修改，指定 webpack 一个或多个入口起点

  在**项目根目录新建 webpack.config.js** 中配置 **entry 属性**

  ```javascript
  module.exports = {
      // 指定入口路径
  	entry: './path/to/my/entry/file.js',
  }
  ```

- 出口 

  webpack **默认以 ./ dist / main.js 作为出口，其他生成文件默认放置在 ./ dist 内**。出口也可以更改，

  在**项目根目录新建 webpack.config.js** 中配置 **output 字段**

  ```javascript
  const path = require('path')
  
  module.exports = {
      // 最好用绝对路径
      entry: path.resolve(__dirname, './path/to/my/entry/file.js'),
      output: {
          // 指定出口路径
          path: path.resolve(__dirname, 'dist'),
          filename: 'my-first-webpack.bundle.js',
          clean: true 				// 在生成打包内容前，清空输出目录(webpack 版本 5.20.0 以上可用)
      }
  }
  ```

- 修改后还是使用 npm run + 自定义命令进行打包

---

# 案例

## AJAX 案例

### 地区查询

- 效果：**传入两个参数**省份和城市，以定位地区。多个参数转化为网页后会用 & 连接。

  ![](./\图片\地区查询.png)

- 代码：

  ```html
  <body>
  	<div class="container">
  		<form id="editForm" class="row">
  			<!-- 输入省份名字 -->
  			<div class="mb-3 col">
          		<label class="form-label">省份名字</label>
          		<input type="text" value="北京" name="province" class="form-control province" placeholder="请输入省份名称" />
        		</div>
        		<!-- 输入城市名字 -->
       		 <div class="mb-3 col">
         			<label class="form-label">城市名字</label>
          		<input type="text" value="北京市" name="city" class="form-control city" placeholder="请输入城市名称" />
        		</div>
      	</form>
      	<button type="button" class="btn btn-primary sel-btn">查询</button>
      	<br><br>
      	<p>地区列表: </p>
      	<ul class="list-group">
        		<!-- 示例地区 -->
        		<li class="list-group-item">东城区</li>
          </ul>
  	</div>
  	<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  	<script>
  		document.querySelector('.sel-btn').addEventListener('click', () => {
              // 获取省份和城市的名字
              let pname = document.querySelector('.province').value
              let cname = document.querySelector('.city').value
              // 基于 axios 请求地区列表数据
              axios({
                  url: 'http://hmajax.itheima.net/api/area',
                  params: {
                      // pname: pName,
                      // cname: cName
                      // 属性名和变量名相同可以只写一个
                      pname,
                      cname
                  }
              }).then(result => {
                  // list 是包含各地区的数组
                  let list = result.data.list
                  // theLi 是处理后的数组，join() 转化为字符串
                  let theLi = list.map(areaName => `<li class="list-group-item">${areaName}</li>`).join('')
                  // 把数据转化为 <li> 插入到页面内
                  document.querySelector('.list-group').innerHTML = theLi
              })
  		})
  	</script>
  </body>
  ```

- 代码2<a id='XHR'>：</a>使用原生 XHR 对象完成。

  ```javascript
  document.querySelector('.sel-btn').addEventListener('click', () => {
      const pname = document.querySelector('.province').value
      const cname = document.querySelector('.city').value
      // 组织查询参数字符串
      const qObj = {
          pname,
          cname
      }
      const paramsObj = new URLSearchParams(qObj)
      const queryString = paramsObj.toString()
      console.log(queryString)
  
      // 使用 XHR 对象，查询地区列表
      const xhr = new XMLHttpRequest()
      xhr.open('get', `http://hmajax.itheima.net/api/area?${queryString}`)
      xhr.addEventListener('loadend', () => {
      console.log(xhr.response)              		// JSON 字符串
      const data = JSON.parse(xhr.response)  		// 转化为对象
      const htmlStr = data.list.map(areaName => {
  		return `<li class="list-group-item">${areaName}</li>`
      }).join('')                              	// 数组转成格式数组再拼成字符串
          console.log(htmlStr)
          document.querySelector('.list-group').innerHTML = htmlStr
      })
      xhr.send()
  })

---

### 用户登录

- 效果：

  ![](./\图片\登录案例.png)

- 代码：

  ```html
  <head>
      <!-- 引入bootstrap.css -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css">
      <!-- 公共 -->
      <style>
          html,
          body {
              background-color: #EDF0F5;
              width: 100%;
              height: 100%;
              display: flex;
              justify-content: center;
              align-items: center;
          }
  
          .container {
              width: 520px;
              height: 540px;
              background-color: #fff;
              padding: 60px;
              box-sizing: border-box;
          }
  
          .container h3 {
              font-weight: 900;
          }
      </style>
      <!-- 表单容器和内容 -->
      <style>
          .form_wrap {
              color: #8B929D !important;
          }
  
          .form-text {
              color: #8B929D !important;
          }
      </style>
      <!-- 提示框样式 -->
      <style>
          .alert {
              transition: .5s;
              opacity: 0;
          }
          .alert.show {
              opacity: 1;
          }
      </style>
  </head>
  <body>
      <div class="container">
          <h3>欢迎-登录</h3>
          <!-- 登录结果-提示框 -->
          <div class="alert alert-success" role="alert">
              提示消息
          </div>
          <!-- 表单 -->
          <div class="form_wrap">
          <form>
              <div class="mb-3">
                  <label for="username" class="form-label">账号名</label>
                  <input type="text" class="form-control username">
              </div>
              <div class="mb-3">
                  <label for="password" class="form-label">密码</label>
                  <input type="password" class="form-control password">
              </div>
              <button type="button" class="btn btn-primary btn-login"> 登 录 </button>
          </form>
          </div>
      </div>
      <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
      <script>
          // 获取提示框
          const myAlert = document.querySelector('.alert')
          // 封装提示框函数
          // 提示框显示文字不同，且背景颜色不同，过 2s 后让提示框消失
          function alertFn(msg, isSuccess) {
              myAlert.classList.add('show')
              myAlert.innerHTML = msg
              const bgStyle = isSuccess ? 'alert-success' : 'alert-danger'
              myAlert.classList.add(bgStyle)
              setTimeout(() => {
                  myAlert.classList.remove('show')
                  // 避免类名冲突
                  myAlert.classList.remove(bgStyle)
              }, 2000)
          }
          // 目标1：点击登录时，用户名和密码长度判断，并提交数据和服务器通信
          document.querySelector('.btn-login').addEventListener('click', () => {
              // 获取用户名和密码
              const username = document.querySelector('.username').value
              const password = document.querySelector('.password').value
              if (username.length < 8) {
                  alertFn('用户名必须大于等于8位', 0)
                  return
              }
              if (password.length < 6) {
                  alertFn('密码必须大于等于6位', 0)
                  return
              }
              axios({
                  url: 'http://hmajax.itheima.net/api/login',
                  method: 'post',
                  data: {
                      username,
                      password
                  }
              }).then(result => {
                  alertFn(result.data.message, 1)
              }).catch(error => {
                  alertFn(error.response.data.message, 0)
              })
          })
    </script>
  </body>
  ```

  升级代码：

  ```html
  <body>
      <div class="container">
          <h3>欢迎-登录</h3>
          <div class="alert alert-success" role="alert">
              提示消息
          </div>
          <div class="form_wrap">
          <!-- 添加类 -->
          <form class="login-form">
              <div class="mb-3">
                  <label for="username" class="form-label">账号名</label>
                  <!-- 添加 name -->
                  <input type="text" class="form-control username" name="username">
              </div>
              <div class="mb-3">
                  <label for="password" class="form-label">密码</label>
                  <!-- 添加 name -->
                  <input type="password" class="form-control password" name="password">
              </div>
              <button type="button" class="btn btn-primary btn-login"> 登 录 </button>
          </form>
          </div>
      </div>
      <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
      <script src="./js/form-serialize.js"></script>
      <script>
          const myAlert = document.querySelector('.alert')
          function alertFn(msg, isSuccess) {
              myAlert.classList.add('show')
              myAlert.innerHTML = msg
              const bgStyle = isSuccess ? 'alert-success' : 'alert-danger'
              myAlert.classList.add(bgStyle)
              setTimeout(() => {
                  myAlert.classList.remove('show')
                  myAlert.classList.remove(bgStyle)
              }, 2000)
          }
          document.querySelector('.btn-login').addEventListener('click', () => {
              // 获取表单
              const form = document.querySelector('.login-form')
              // 使用 serialize 插件获取登录表单对象
              const data = serialize(form, {hash: true, empty: true})
              // 对象解构
              const {username, password} = data
              if (username.length < 8) {
                  alertFn('用户名必须大于等于8位', 0)
                  return
              }
              if (password.length < 6) {
                  alertFn('密码必须大于等于6位', 0)
                  return
              }
              axios({
                  url: 'http://hmajax.itheima.net/api/login',
                  method: 'post',
                  data: {
                      username,
                      password
                  }
              }).then(result => {
                  alertFn(result.data.message, 1)
              }).catch(error => {
                  alertFn(error.response.data.message, 0)
              })
          })
  	</script>
  </body>
  ```


---

### 图书管理

- 效果：点击添加出现弹框，添加图书列表展示。

  ![](./\图片\图书管理.png)

- 代码：

  html 略

  JS 部分

  ```javascript
  // 功能1：获取图书
  // 创建一个昵称
  const creator = 'liutubo'
  // 渲染函数
  function getBookList() {
      // 获取数据
      axios({
          url: 'http://hmajax.itheima.net/api/books',
          params: {
              // 用昵称获取属于我的图书列表（因为服务器每个人拥有的图书不一样）
              creator
          }
      }).then(result => {
          // 获取图书列表
          const bookList = result.data.data
          // 转化为字符串
          const htmlStr = bookList.map((item, index) => {
              return `
              <tr>
                  <td>${index + 1}</td>
                  <td>${item.bookname}</td>
                  <td>${item.author}</td>
                  <td>${item.publisher}</td>
                  <!-- 添加自定义属性，以方便删除 -->
                  <td data-id=${item.id}>
                      <span class="del">删除</span>
                      <span class="edit">编辑</span>
                  </td>
              </tr>
            `
          }).join('')
          // 插入到网页
          document.querySelector('.list').innerHTML = htmlStr
      })
  }
  getBookList()
  // 功能2：上传图书
  // 获取弹框
  const addModalDom = document.querySelector('.add-modal')
  // 创建弹框对象
  const addModal = new bootstrap.Modal(addModalDom)
  // 为保存按钮绑定点击事件，点击后隐藏弹框
  document.querySelector('.add-btn').addEventListener('click', () => {
      // 用 seralize 插件获取表单
      const addForm = document.querySelector('.add-form')
      const bookObj = serialize(addForm, {hash: true, empty: true})
      // 提交到服务器保存
      axios({
          url: 'http://hmajax.itheima.net/api/books',
          method: 'post',
          // 服务器要求四个参数，bookObj 内有三个满足要求的参数，还差个昵称
          data: {
              // 把对象展开
              ...bookObj,
              creator
          }
      }).then(result => {
          // 添加成功后重新渲染列表
          getBookList()
          // 重置表单
          addForm.reset()
      })
      addModal.hide()
  })
  // 功能3：删除图书
  // 事件委托给父级 tbody 以绑定点击事件
  document.querySelector('.list').addEventListener('click', e => {
      if (e.target.classList.contains('del')) {
          // 删除该元素，获取点击删除按钮的父级位置的自定义id
          const theId = e.target.parentNode.dataset.id
          axios({
              // 路径传参
              url: `http://hmajax.itheima.net/api/books/${theId}`,
              method: 'delete'
          }).then(() => {
              getBookList()
          })
      }
  })
  // 功能4：编辑图书
  // 点击编辑，显示弹框，输入数据，上传服务器，刷新页面
  const editDom = document.querySelector('.edit-modal')
  const editModal = new bootstrap.Modal(editDom)
  document.querySelector('.list').addEventListener('click', e => {
      if (e.target.classList.contains('edit')) {
          // 获取图书id
          const theId = e.target.parentNode.dataset.id
          // 用 id 去服务器获取图书详情
          axios({
              url: `http://hmajax.itheima.net/api/books/${theId}`,
          }).then(result => {
              const bookObj = result.data.data
              // 回显在表单
              // 把图书对象的键取出来，返回数组
              const keys = Object.keys(bookObj)   // ['id', 'bookname', 'author', 'publisher']
              // 遍历属性，作为类名去找到对应表单以赋值
              keys.forEach(key => {
                  document.querySelector(`.edit-form .${key}`).value = bookObj[key]
              })
          })
          editModal.show()
      }
  })
  // 点击修改按钮，绑定点击事件
  document.querySelector('.edit-btn').addEventListener('click', () => {
      const editForm = document.querySelector('.edit-form')
      const {id, bookname, author, publisher} = serialize(editForm, {hash: true, empty: true})
      axios({
          url: `http://hmajax.itheima.net/api/books/${id}`,
          method: 'put',
          data: {
              bookname,
              author,
              publisher,
              creator
          }
      }).then(() => {
          getBookList()
          editModal.hide()
      })
  })
  ```

---

### 个人信息设置

- 效果：

  ![](./\图片\个人信息.png)

- 步骤：

1. 使用昵称从服务器获取数据并渲染
2. 点击修改头像按钮，创建表单对象，拼接图片与昵称并上传服务器，接收返回的图片地址，回显在网页上
3. 收集用户输入信息的表单，处理后提交到服务器，创建 toast 对象，显示提示框告知用户上传成功

- 代码：

  ```html
  <head>
  	<!-- 略 -->
  </head>
  <body>
      <!-- toast 提示框 -->
      <div class="toast my-toast" data-bs-delay="1500">
  		<!-- 略 -->
      </div>
      <!-- 核心内容区域 -->
      <div class="container">
  		<!-- 略 -->
          <form class="user-form" action="javascript:;">
              <!-- 略 -->
              <input id="email" name="email" class="email" type="text" placeholder="请输入邮箱" autocomplete="off">
              <!-- 略 -->
              <input id="nickname" name="nickname" class="nickname" type="text" placeholder="请输入昵称" autocomplete="off">
              <!-- 略 -->
              <label class="male-label"><input type="radio" name="gender" class="gender" value="0">男</label>
              <!-- 略 -->
              <label class="male-label"><input type="radio" name="gender" class="gender" value="1">女</label>
              <!-- 略 -->
              <textarea id="desc" name="desc" class="desc" placeholder="请输入个人简介" cols="20" rows="10" autocomplete="off"></textarea>
  			<button class="submit">提交</button>
          </form>
        	</div>
              <div class="avatar-box">
                  <h4 class="avatar-title">头像</h3>
                  <img class="prew" src="./img/头像.png" alt="">
                  <!-- label 可以扩大表单交互范围 for属性的值关联了 表单 id 的值 -->
                  <!-- 所以点在 label 上就相当于点在表单上 -->
                  <label for="upload">更换头像</label>
                  <input id="upload" type="file" class="upload">
              </div>
      	</div>
      </div>
      <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.min.js"></script>
      <script src="./lib/form-serialize.js"></script>
      <script>
      	// 打开网页就从服务器获取数据渲染
          const creator = 'liutubo'
          axios({
              url: 'http://hmajax.itheima.net/api/settings',
              params: {
                  creator
              }
          }).then(result => {
              // 获取用户数据
              const userObj = result.data.data    // {avatar: 头像, desc: 简介, email: 邮箱, gender: 性别, nickname: 昵称}
              // 遍历
              Object.keys(userObj).forEach(key => {
                  // 网页里头像标签类名是 prew，而不是 avatar
                  // 处理头像地址
                  if (key === 'avatar') {
                      document.querySelector('.prew').src = userObj[key]
                  } else if (key === 'gender') {
                      // 处理性别 - 因为不是直接改 value，而是改 checked
                      // 获取性别元素列表
                      const gRadioList = document.querySelectorAll('.gender')
                      // 获取服务器上的性别，性别数字 0为男，1为女
                      const gNum = userObj[key]
                      // 可通过性别数字找到对应性别单选框，设为选中
                      gRadioList[gNum].checked = true
                  } else {
                      // 赋予默认内容
                      document.querySelector(`.${key}`).value = userObj[key]
                  }
              })
          })
          // 修改头像
          document.querySelector('.upload').addEventListener('change', e => {
              // 准备一个表单数据对象
              const fd = new FormData()
              // 接口文档要求两个参数 文件和昵称
              fd.append('avatar', e.target.files[0])
              fd.append('creator', creator)
              // 提交到服务器
              axios({
                  url: 'http://hmajax.itheima.net/api/avatar',
                  method: 'put',
                  data: fd
              }).then(result => {
                  const imgUrl = result.data.data.avatar
                  // 把新头像回显在页面上
                  document.querySelector('.prew').src = imgUrl
              })
          })
          // 信息修改
          document.querySelector('.submit').addEventListener('click', () => {
              // 收集表单数据
              const userForm = document.querySelector('.user-form')
              const userObj = serialize(userForm, {hash: true, empty: true})
              // 为对象添加 creator 字段
              userObj.creator = creator
              // 服务器要求：要把性别的字符转化成数字
              userObj.gender = +userObj.gender
              axios({
                  url: 'http://hmajax.itheima.net/api/settings',
                  method: 'put',
                  data: userObj
              }).then(result => {
                  console.log(result)
                  // 创建 toast 对象
                  const toastDom = document.querySelector('.my-toast')
                  const toast = new bootstrap.Toast(toastDom)
                  // 显示提示框
                  toast.show()
              })
          })
      </script>
  </body>
  ```


---

### 天气预报

- 效果：

  ![](./\图片\天气预报.png)

- 步骤：

1. 进入页面默认获取北京市数据，展示
2. 搜索城市列表，绑定 input 事件，获取关键字，获取展示城市列表数据
3. 点击想查看的城市，获取城市编码，替换城市数据，展示。

- 服务器返回信息图1：

  ![](./图片\天气预报返回1.png)

- 服务器返回信息图2：

  ![](./\图片\天气预报返回2.png)

- 代码：

  ```javascript
  // 传入城市编码，渲染该城市天气页面
  function getWeather(citycode) {
      myAxios({
          url: 'http://hmajax.itheima.net/api/weather',
          params: {
              city: citycode
          }
      }).then(result => {
          // result 的结构为看返回图 1
          console.log(result)
          const wObj = result.data    // 天气数据
          // 左上角阳历与农历日期
          const dataStr = `
              <span class="dateShort">${wObj.date}</span>
              <span class="calendar">农历&nbsp;
              <span class="dateLunar">${wObj.dateLunar}</span>
              </span>
          `
          document.querySelector('.title').innerHTML = dataStr
          // 右上角城市名字
          document.querySelector('.area').innerHTML = wObj.area
          // 中间当日气温
          const nowWStr = `
              <div class="tem-box">
                  <span class="temp">
                  <span class="temperature">${wObj.temperature}</span>
                  <span>°</span>
                  </span>
              </div>
              <div class="climate-box">
                  <div class="air">
                      <span class="psPm25">${wObj.psPm25}</span>
                      <span class="psPm25Level">${wObj.psPm25Level}</span>
                  </div>
                  <ul class="weather-list">
                      <li>
                          <img src=${wObj.weatherImg} class="weatherImg" alt="">
                          <span class="weather">${wObj.weather}</span>
                      </li>
                      <li class="windDirection">${wObj.windDirection}</li>
                      <li class="windPower">${wObj.windPower}</li>
                  </ul>
              </div>
          `
          document.querySelector('.weather-box').innerHTML = nowWStr
          // 中间当天天气
          const twObj = wObj.todayWeather
          const todayWStr = `
              <div class="range-box">
                  <span>今天：</span>
                  <span class="range">
                  <span class="weather">${twObj.weather}</span>
                  <span class="temNight">${twObj.temNight}</span>
                  <span>-</span>
                  <span class="temDay">${twObj.temDay}</span>
                  <span>℃</span>
                  </span>
              </div>
              <ul class="sun-list">
                  <li>
                      <span>紫外线</span>
                      <span class="ultraviolet">${twObj.ultraviolet}</span>
                  </li>
                  <li>
                      <span>湿度</span>
                      <span class="humidity">${twObj.humidity}</span>%
                  </li>
                  <li>
                      <span>日出</span>
                      <span class="sunriseTime">${twObj.sunriseTime}</span>
                  </li>
                  <li>
                      <span>日落</span>
                      <span class="sunsetTime">${twObj.sunsetTime}</span>
                  </li>
              </ul>
          `
          // 7 日天气预报
          const dayForecast = wObj.dayForecast
          const dayForecastStr = dayForecast.map(item => {
              return `
                  <li class="item">
                      <div class="date-box">
                          <span class="dateFormat">${item.dateFormat}</span>
                          <span class="date">${item.date}</span>
                      </div>
                      <img src=${item.weatherImg} alt="" class="weatherImg">
                      <span class="weather">${item.weather}</span>
                      <div class="temp">
                          <span class="temNight">${item.temNight}</span>-
                          <span class="temDay">${item.temDay}</span>
                          <span>℃</span>
                      </div>
                      <div class="wind">
                          <span class="windDirection">${item.windDirection}</span>
                          <span class="windPower">${item.windPower}</span>
                      </div>
                  </li>
              `
          }).join('')
          document.querySelector('.week-wrap').innerHTML = dayForecastStr
      })
  }
  // 默认进入网页就获取天气数据 - 北京市城市编码
  getWeather('110100')
  
  // 搜索框 - 城市列表
  document.querySelector('.search-city').addEventListener('input', e => {
      // e.target.value 为获取用户实时输入数据
      myAxios({
          url: 'http://hmajax.itheima.net/api/weather/city',
          params: {
              city: e.target.value
          }
      }).then(result => {
          // 返回结果看返回图 2
          console.log(result)
          const liStr = result.data.map(item => {
              // 为了得到城市码搜索天气，把城市码加在自定义属性里
              return `<li class="city-item" data-code="${item.code}">${item.name}</li>`
          }).join('')
          document.querySelector('.search-list').innerHTML = liStr
      })
  })
  // 点击搜索框获取城市编码
  document.querySelector('.search-list').addEventListener('click', e => {
      // 只有点击了城市的 li（li 标签有 city-item）
      if (e.target.classList.contains('city-item')) {
          // 从自定义属性获取城市编码
          const cityCode = e.target.dataset.code
          getWeather(cityCode)
      }
  })
  ```

---

### 商品分类

- 效果：把所有商品同时渲染在页面上。

  ![](./\图片\商品分类.png)



- 步骤：

1. 先获取所有一级分类数据
2. 遍历商品 id，创建获取二级分类的请求
3. **合并所有二级分类的 Promise 对象**
4. 请求同时成功，渲染页面。

- 服务器返回信息图1：

  ![](./\图片\商品分类返回1.png)

- 服务器返回信息图2：

  ![](./\图片\商品分类返回2.png)

- 代码：

  ```javascript
  axios({
  	url: 'http://hmajax.itheima.net/api/category/top'
  }).then(result => {
      console.log(result)       // 获取一级商品分类列表，看图 1
      const secPromiseList = result.data.data.map(item => {
  		// 遍历一级商品分类的 id 转化为 axios 请求以得到二级商品
  		return axios({
              url: 'http://hmajax.itheima.net/api/category/sub',
              params: {
              	id: item.id       // 这是 一级分类的 id 
          	}
  		})
  	})
      console.log(secPromiseList)       // 数组，里面是九个二级分类请求 Promise 对象
      // 合并 9 个 Promise 对象
      const p = Promise.all(secPromiseList)
      p.then(result => {
  		console.log(result)   // 看图 2
          // 展示在页面上
          const htmlStr = result.map(item => {
              const dataObj = item.data.data  // 取出关键数据对象
              // 注意 return 里面用 ${} 里写表达式
              return ` 
                  <div class="item">
                      <h3>${dataObj.name}</h3>
                      <ul>
  						${dataObj.children.map(item => {
  							return `
  								<li>
  									<a href="javascript:;">
                              			<img src=${item.picture}>
                              			<p>${item.name}</p>
                            			</a>
                          		</li>
                        		`
  						}).join('')}
  					</ul>
  				</div>
  			`
  		}).join('')
  		document.querySelector('.sub-list').innerHTML = htmlStr
  	})
  })
  ```
  

---

### 省份菜单 + 意见反馈

- 效果：

  ![](./\图片\地区菜单.png)

- 步骤：

1. 设置省份数据下拉菜单
2. 切换省份，监听省份的变化，设置城市数据到下拉菜单，并清空地区下拉菜单
3. 切换城市，监听城市的变化，设置地区数据到下拉菜单
4. 设置昵称与评价，提交反馈

- 代码：

  ```javascript
  // 省份数据放在下拉菜单
  axios({
      url: 'http://hmajax.itheima.net/api/province'
  }).then(result => {
      // 前一个 pname 是用于获取点击下拉菜单中的省份
      // 后一个 pname 是给用户看的
      const optionStr = result.data.list.map(pname => `<option value="${pname}">${pname}</option>`).join('')
      // 默认的省份二字与各地省份拼接在一起并插入 select
      document.querySelector('.province').innerHTML = `<option value="">省份</option>` + optionStr
  })
  // 监测省份改变事件，渲染城市下拉菜单，清空地区下拉菜单
  document.querySelector('.province').addEventListener('change', async e => {
      // 获取用户点击的省份
      console.log(e.target.value)
      // 用 async 和 await
      const result = await axios({
          url: 'http://hmajax.itheima.net/api/city',
          params: {
              pname: e.target.value
          }
      })
      // 得到城市数据，遍历
      const optionStr = result.data.list.map(cname => `<option value="${cname}">${cname}</option>`).join('')
      // 默认的城市二字与各地省份拼接在一起并插入 select
      document.querySelector('.city').innerHTML = `<option value="">城市</option>` + optionStr
      // 选完省市区，如果重新选择省份，地区必须清空
      document.querySelector('.area').innerHTML = `<option value="">地区</option>`
  })
  // 检测城市改变事件，渲染地区下拉菜单
  document.querySelector('.city').addEventListener('change', async e => {
      // 获取用户点击的城市
      console.log(e.target.value)
      const result = await axios({
          url: 'http://hmajax.itheima.net/api/area', 
          params: {
              pname: document.querySelector('.province').value,
              cname: e.target.value
          }
      })
      const optionStr = result.data.list.map(aname => `<option value="${aname}">${aname}</option>`).join('')
      // 默认的城市二字与各地省份拼接在一起并插入 select
      document.querySelector('.area').innerHTML = `<option value="">地区</option>` + optionStr
  })
  // 收集数据提交
  // 给提交按钮绑定点击事件
  document.querySelector('.submit').addEventListener('click', async () => {
      // 别忘了引入 serialize 插件
      const form = document.querySelector('.info-form')
      // 获取用户准备的数据
      const data = serialize(form, {hash: true, empty: true})
      try {
          const result= await axios({
              url: 'http://hmajax.itheima.net/api/feedback',
              method: 'post',
              // 这里 data 已经是对象了
              data
          })
          console.log(result)
          // 提示用户成功
          alert(result.data.message)
      } catch (error) {
          console.dir(error.response.data.message)
      }
  })
  ```


---

## 头条新闻管理

- 功能：供内部人员使用，对数据进行管理，增删改查，

1. 登录（后端要求任意手机号，密码为246810）与登录权限判断
2. 登录后进入后台，可筛选文章，分页切换文章，编辑文章。
3. 点击编辑文章， 选择标题，频道，封面与内容进行修改，
4. 删除文章功能。
5. 发布文章，选择标题，频道，封面与内容。

- 项目准备

1. 局域 **Bootstrap** 搭建网站标签和样式
2. 集成 **wangEditor 插件**实现富文本编辑器（即图中的文本编辑器）
3. 使用原生 JS 完成**增删改查**业务
4. 基于 axios 与头条新闻线上接口交互
5. 使用 **axios 拦截器**进行权限判断

---

### 验证码登录

- 效果：

  ![](./\图片\头条-登录.png)

- 基地址概念

  要先把 axios 请求的 url 中**公共部分**，即请求**基地址**提取出来，免得一个项目中写一堆链接。

- 步骤：

1. 在 utils / request.js 配置 axios 请求基地址
2. 收集手机号和验证码数据
3. 基于 axios 调用验证码登录接口
4. 使用 Bootstrap 的 Alert 警告框反馈结果给用户
5. 登陆成功后跳转页面，并把登录好的昵称显示在右上角

- 代码：

1. utils / **request.js** 被项目各个页面所引用，用于提取请求基地址和添加请求拦截器

   ```javascript
   // axios 公共配置
   
   // 请求地址公共部分
   axios.defaults.baseURL = 'http://geek.itheima.net'
   
   // 添加请求拦截器
   axios.interceptors.request.use(function (config) {
       // 在发送请求前统一携带 token 令牌字符串在请求头上
       const token = localStorage.getItem('token')
       // 从本次配置文件的请求头上添加参数名
       token && (config.headers.Authorization = `Bearer ${token}`)
       return config;
   }, function (error) {
       // 下面反而用的很少，不用管
       return Promise.reject(error)
   });
   
   // 添加响应拦截器
   axios.interceptors.response.use(function (response) {
       // 2xx 范围内的状态码都会触发该函数。
       const result = response.data
       return response;
   }, function (error) {
       // 超出 2xx 范围的状态码都会触发该函数。这里统一对 401 身份验证失败情况做出处理
       // 这里的 ? 可以避免报错，如果前面没有值后面就不执行了
       if (error?.response?.status === 401) {
           alert('身份验证失败，请重新登陆')
           // 清空本地存储
           localStorage.clear()
           // 返回登录页
           location.href = '../login/index.html'
       }
       return Promise.reject(error);
   });
   ```

2. utils / **alert.js** 内封装了提示框函数，借用 Bootstrap 插件

   ```javascript
   // 封装好的提示框函数
   
   function myAlert(isSuccess, msg) {
       // 获取 div 盒子
       const myAlert = document.querySelector('.alert')
       myAlert.classList.add(isSuccess ? 'alert-success' : 'alert-danger')
       myAlert.innerHTML = msg
       // 添加此类名出现提示框
       myAlert.classList.add('show')
       // 两秒后移除清空
       setTimeout(() => {
           myAlert.classList.remove(isSuccess ? 'alert-success' : 'alert-danger')
           myAlert.innerHTML = ''
           myAlert.classList.remove('show')
       }, 2000)
   }
   ```

3. login / **index.js** 的内容（index.html 已导入所需的插件）

   ```javascript
   // 登录页面对应的 js
   
   document.querySelector('.btn').addEventListener('click', () => {
       // 收集表单数据
       const form = document.querySelector('.login-form')
       const data = serialize(form, {hash: true, empty: true})
       axios({
           url: '/v1_0/authorizations',
           method: 'post',
           data
       }).then(result => {
           console.log(result)							// 返回 token
           // 提示框
           myAlert(true, '登陆成功')
           // 把 token 保存到本地
           localStorage.setItem('token', result.data.token)
           // 跳转到网页 1.5 秒后跳转
           setTimeout(() => {
               location.href = '../content/index.html'
           }, 1500)
       }).catch(error => {
           console.dir(error.response.data.message)    // 验证码不正确
           myAlert(false, error.response.data.message)        
       })
   })
   ```

   成功时返回的 token 是一个长字符串，是令牌，用于控制访问权限。**前端来判断有无 token**，后端判断 token 有效性。

4. utils / **auth.js** 的内容

   这里是保证进入管理主页后的三个功能：

   第一，没有登录就进入是不可以的，检测 token 是否存在，强制打回

   第二，登陆成功跳转到管理主页，要把登录昵称自动显示在右上角，为此引入 **axios请求拦截器**

   第三，退出登录功能，点击退出清空本地缓存
   
   ```javascript
   // 权限插件（被引入到了除登录页面，以外的其他所有页面）
   
   // 获取 token
   const token = localStorage.getItem('token')
   if (!token) {
       // token 不存在，强制打回登录页面
       location.href = '../login/index.html'
   }
   // 引入了 utils/request.js 设置请求拦截器，使统一携带 token
   // 接口文档规定了传参为 Bearer[空格]token值，这个功能写在了 request.js，所以这里不传参
   axios({
       url: '/v1_0/user/profile'
   }).then(result => {
       console.log(result)     // 返回值包含手机号与昵称等
       // 取出昵称
       const username = result.data.name
       document.querySelector('.nick-name').innerHTML = username
   })
   // 退出登录
   document.querySelector('.quit').addEventListener('click', e => {
       localStorage.clear()
       location.href = '../login/index.html'
   })
   ```


---

### 发布文章页 - wangEditor 插件

- 效果

  ![](./\图片\头条-发布文章.png)

- 富文本编辑器

  即可以选择样式的文本编辑器，会被解析成带标签的格式，使用 [wangEditor 插件](https://www.wangeditor.com/) 完成，可在官网查看指南。

- 步骤

1. 引入 wangEditor 插件实现**富文本编辑器**（引入 CSS 样式，定义 HTML 结构，引入 JS 创建编辑器监听内容改变，保存在**隐藏**文本域（这个文本域加了 hidden 属性不可见，用于获取用户输入内容以发布）
2. 展示频道列表（获取频道列表数据，插入到下拉菜单）
3. 文章封面设置，选择文件保存在 FromData，单独上传图片得到 URL 网址，回显并切换 img 标签显示（同时隐藏 + 标签）
4. 发布文章，收集文章内容，并提交保存，基于 form-serialize 插件收集表单数据对象，提交到服务器，调用 Alert 警告框反馈结果给用户

- 代码：

1. utils / **editor.js** 即富文本编辑器内容，从官网文档拷贝修改

   ```javascript
   // 富文本编辑器
   // 创建编辑器函数，创建工具栏函数
   const { createEditor, createToolbar } = window.wangEditor
   
   // 编辑器配置对象
   const editorConfig = {
       // 占位提示文字
       placeholder: '发布文章内容',
       // 编辑器变化时出发回调函数
       onChange(editor) {
           // html 是用户输入的带标签的文本内容
           const html = editor.getHtml()
           console.log('editor content', html)
           // 为了后面快速收集整个表单内容做铺垫 同步到 <textarea>
           document.querySelector('.publish-content').value = html
       }
   }
   
   const editor = createEditor({
       // 编辑器创建位置
       selector: '#editor-container',
       // 默认内容
       html: '<p><br></p>',
       config: editorConfig,
       // 模式选择：全部或简易功能
       mode: 'default', // or 'simple'
   })
   
   // 工具栏配置对象
   const toolbarConfig = {}
   
   const toolbar = createToolbar({
       // 为指定编辑器创建工具栏
       editor,
       // 工具栏创建位置
       selector: '#toolbar-container',
       config: toolbarConfig,
       mode: 'default', // or 'simple'
   })
   ```

2. publish / **index.js** 

   ```javascript
   // 频道功能
   // 由于发布页有频道列表,内容页也有频道列表,重复使用应封装成函数
   async function setChannelList() {
       const res = await axios({
           url: '/v1_0/channels'
       })
       // 频道列表 => 字符串 => 拼接到下拉列表
       const htmlStr = res.data.channels.map(item => `<option value="${item.id}">${item.name}</option>`).join('')
       document.querySelector('.form-select').innerHTML = '<option value="" selected="">请选择文章频道</option>' + htmlStr
   }
   setChannelList()
   
   // 封面功能
   document.querySelector('.img-file').addEventListener('change', async e => {
       // 用户选择要上传的图片元素
       const file = e.target.files[0]
       const fd = new FormData()
       fd.append('image', file)
       const res = await axios({
           url: '/v1_0/upload',
           method: 'post',
           data: fd
       })
       // 图片回显 - 先获取图片 URL
       const imgUrl = res.data.url
       // 获取 img 标签修改 src 地址
       document.querySelector('.rounded').src = imgUrl
       // img 默认隐藏，显示和隐藏的属性写在了 css 的 show 类名和 hide 类名
       // 显示图片
       document.querySelector('.rounded').classList.add('show')
       // 隐藏带 + 号的 label 标签
       document.querySelector('.place').classList.add('hide')
   })
   // 点击 img 标签 重新触发 click 事件方法
   document.querySelector('.rounded').addEventListener('click', () => {
       // 触发点击，弹出上传图片
       document.querySelector('.img-file').click()
   })
   
   // 发布文章收集并保存
   document.querySelector('.send').addEventListener('click', async e => {
       // 获取表单
       const form = document.querySelector('.art-form')
       const data = serialize(form, {hash: true, empty: true})
       // 获取的表单有个 id 属性，这里用不上，应删除
       delete data.id
       // 要发到服务器的请求中，参数需要图片 URL 地址，要保存到 data 对象
       // 服务器要求格式
       data.cover = {
           type: 1,    // 封面类型
           images: [document.querySelector('.rounded').src]    // URL 网址
       }
       try {
           const res = await axios({
               url: '/v1_0/mp/articles',
               method: 'post',
               data
           })
           myAlert(true, '发布成功')
           // 重置表单并1.5秒后跳转到列表页
           // form 只能清空表单内容
           form.reset()
           // 封面手动重置
           document.querySelector('.rounded').src = ''
           document.querySelector('.rounded').classList.remove('show')
           document.querySelector('.place').classList.remove('hide')
           // 富文本编辑器手动重置
           editor.setHtml('')
           setTimeout(() => {
               location.href = '../content/index.html'
           }, 1500)
       } catch (error) {
           myAlert(false, error.response.data.message)
       }
   })
   ```
   
   点击文章管理会跳转到 publish / index.js，编辑与发布共用一个表单，区别在于解析 URL 上有没有 ? + 文章 id
   
   ```javascript
   // 编辑文章与发布文章共用一个表单
   // 文章管理页点击编辑文章后跳转到本页面 - 接收参数判断
   // 立即执行 且 防止变量污染
   ;(function(){
       // 获取 URL ?后的 id
       const paramStr = location.search
       const params = new URLSearchParams(paramStr)
       // 接收并解析 id 参数
       params.forEach(async (value, key) => {
           // 当前有要编辑的文章 id 要被回显到页面
           if (key === 'id') {
               document.querySelector('.title span').innerHTML = '修改文章'
               document.querySelector('.send').innerHTML = '修改'
               // 回显
               const res = await axios({
                   url: `/v1_0/mp/articles/${value}`
               })
               // 对返回结果做操作，定义仅需要的值拼成对象，用于回显
               const dataObj = {
                   channel_id: res.data.channel_id,
                   title: res.data.title,
                   rounded: res.data.cover.images[0],
                   content: res.data.content,
                   id: res.data.id
               }
               // 遍历数据对象属性，回显在页面上
               Object.keys(dataObj).forEach(key => {
                   if (key === 'rounded') {
                       // 封面比较特殊不能直接赋值
                       if (dataObj[key]) {
                           // 有封面
                           document.querySelector('.rounded').src = dataObj[key]
                           document.querySelector('.rounded').classList.add('show')
                           document.querySelector('.place').classList.add('hide')
                       }
                   } else if (key === 'content') {
                       // 富文本编辑器的内容也比较特殊，要用特殊方法
                       editor.setHtml(dataObj[key])
                   } else {// 其他情况
                       // 频道id 标题 id 的属性名都在对应标签的 name 属性上
                       // 所以根据 name 属性选择器来匹配标签
                       document.querySelector(`[name=${key}]`).value = dataObj[key]
                   }
               })
           }
       })
   })();
   // 编辑文章的点击修改（发布）按钮
   document.querySelector('.send').addEventListener('click', async e => {
       if (e.target.innerHTML !== '修改') return
       const form = document.querySelector('.art-form')
       const data = serialize(form, {hash: true, empty: true})
       try {
           const res = await axios({
               url: `/v1_0/mp/articles/${data.id}`,
               method: 'put',
               data: {
                   ...data,
                   cover: {
                       // 有无封面图
                       type: document.querySelector('.rounded').src ? 1 : 0,
                       images: [document.querySelector('.rounded').src]
                   }
               }
           })
           myAlert(true, '修改文章成功')
       } catch (error) {
           myAlert(false, error.response.data.message)
       }
   })
   ```
   

---

### 文章管理页

- 效果

  ![](./\图片\头条-文章管理.png)

- 步骤

1. 获取文章列表并展示，先根据接口文档**拼接查询参数对象**，然后提交到服务器，把结果渲染到页面上。
2. 设置频道列表数据，发布文章的页面也用过，直接复制函数即可，监听筛选条件改变，**保存查询信息到查询参数对象**。点击筛选时，传递**查询参数对象**到服务器。
3. 分页管理，保存并设置文章总条数，点击下一页做临界值判断，并切换页码参数请求最新数据
4. 删除功能，绑定点击事件，获取文章 id，与服务器交互，重新渲染页面。删除成功时，如果刚好是最后一条（独占一页），让当前页码 page--（也不能只有一条，减到第 0 页）
5. 编辑功能，与发布文章共用一个表单，所以这部分代码写在了发布文章的 js 内

- 代码：

  ```javascript
  // 查询参数对象
  const queryObj = {
      status: '',          // 文章状态 1-待审核, 2-审核通过，空字符串为全部
      channel_id: '',      // 文章频道 id，空字符串为全部
      page: 1,             // 当前页码
      per_page: 2          // 当前页面条数
  }
  // 保存文章总条数
  let totalCount = 0
  // 用查询参数对象获取文章列表渲染函数
  async function setArticleList() {
      // 获取文章列表数据
      const res = await axios({
          url: '/v1_0/mp/articles',
          params: queryObj
      })
      // 图片需要判断是否有图，没图用默认的图
      const htmlStr = res.data.results.map(item => `
      <tr>
          <td>
              <img src=${item.cover.type === 0 ? `https://img2.baidu.com/it/u=2640406343,1419332367&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=708&amp;h=500` : item.cover.images[0]} alt="">
          </td>
          <td>${item.title}</td>
          <td>
              ${item.status === 1 ? `<span class="badge text-bg-primary">待审核</span>` : `<span class="badge text-bg-success">审核通过</span>`}
          </td>
          <td>
              <span>${item.pubdate}</span>
          </td>
          <td>
              <span>${item.read_count}</span>
          </td>
          <td>
              <span>${item.comment_count}</span>
          </td>
          <td>
              <span>${item.like_count}</span>
          </td>
          <td data-id="${item.id}">
              <i class="bi bi-pencil-square edit"></i>
              <i class="bi bi-trash3 del"></i>
          </td>
      </tr>
      `   
      ).join('')
      document.querySelector('.art-list').innerHTML = htmlStr
      // 保存总页数并渲染在下面的条数上
      totalCount = res.data.total_count
      document.querySelector('.total-count').innerHTML = `共${totalCount}条`
  }
  setArticleList()
  // 频道列表
  async function setChannelList() {
      const res = await axios({
          url: '/v1_0/channels'
      })
      const htmlStr = res.data.channels.map(item => `<option value="${item.id}">${item.name}</option>`).join('')
      document.querySelector('.form-select').innerHTML = '<option value="" selected="">请选择文章频道</option>' + htmlStr
  }
  setChannelList()
  // 筛选状态 - 全部/待审核/审核通过
  // 获取三个单选框标签
  document.querySelectorAll('.form-check-input').forEach(radio => {
      // 监听用户点击了哪个单选框并改变查询参数对象的值
      radio.addEventListener('change', e => {
          queryObj.status = e.target.value
      })
  })
  // 筛选频道
  document.querySelector('.form-select').addEventListener('change', e => {
      // 监听用户修改了频道，获取频道的值，修改查询参数对象
      queryObj.channel_id = e.target.value
  })
  // 筛选按钮
  document.querySelector('.sel-btn').addEventListener('click', () => setArticleList())
  // 点击下一页，做临界值判断
  document.querySelector('.next').addEventListener('click', () => {
      // 临界值判断
      if (queryObj.page < Math.ceil(totalCount / queryObj.per_page)) {
          queryObj.page++
          document.querySelector('.page-now').innerHTML = `第${queryObj.page}页`
          setArticleList()
      }
  })
  // 点击上一页
  document.querySelector('.last').addEventListener('click', () => {
      if (queryObj.page > 1) {
          queryObj.page--
          document.querySelector('.page-now').innerHTML = `第${queryObj.page}页`
          setArticleList()
      }
  })
  // 删除文章 点击获取文章 id
  document.querySelector('.art-list').addEventListener('click', async e => {
      if (e.target.classList.contains('del')) {
          const delId = e.target.parentNode.dataset.id
          const res = await axios({
              url: `/v1_0/mp/articles/${delId}`,
              method: 'delete'
          })
          // 删除最后一页的最后一条 应自动向前翻页
          const children = document.querySelector('.art-list').children
          // 只有一条且不是第一页
          if (children.length === 1 && queryObj.page !== 1) {
              queryObj.page--
              document.querySelector('.page-now').innerHTML = `第${queryObj.page}页`
          }
          setArticleList()
      }
  })
  // 编辑文章 点击获取文章 id，跳转到发布页面，传 id 到服务器，回显
  document.querySelector('.art-list').addEventListener('click', async e => {
      if (e.target.classList.contains('edit')) {
          const artId = e.target.parentNode.dataset.id
          // 跳转页面，在 URL ?后直接携带 id
          location.href = `../publish/index.html?id=${artId}`
      }
  })
  ```

---

最后看到 P100 看了一半
